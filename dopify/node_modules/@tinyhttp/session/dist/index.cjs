'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var events = require('events');
var cookie = require('@tinyhttp/cookie');
var url = require('url');
var signature = require('@tinyhttp/cookie-signature');
var crypto = require('crypto');
var nanoid = require('nanoid');
var onHeaders = require('on-headers');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var cookie__namespace = /*#__PURE__*/_interopNamespace(cookie);
var url__default = /*#__PURE__*/_interopDefaultLegacy(url);
var signature__namespace = /*#__PURE__*/_interopNamespace(signature);
var onHeaders__default = /*#__PURE__*/_interopDefaultLegacy(onHeaders);

const generateSessionId = () => nanoid.nanoid(24);
function hash(sess) {
    // serialize
    const str = JSON.stringify(sess, (key, val) => {
        // ignore sess.cookie property
        if (key === 'cookie' || key == 'store')
            return;
        return val;
    });
    // hash
    return crypto.createHash('sha1').update(str, 'utf8').digest('hex');
}
class Cookie {
    constructor(options) {
        this._expires = false;
        this.secure = false;
        this.httpOnly = true;
        this.path = '/';
        const opts = options || {};
        this.expires = opts.expires || false;
        this.path = typeof opts.path !== 'undefined' ? opts.path : '/';
        this.maxAge = opts.maxAge;
        this.originalMaxAge = opts.originalMaxAge === undefined ? opts.maxAge || 0 : opts.originalMaxAge;
        this.domain = opts.domain;
        this.sameSite = opts.sameSite;
        this.httpOnly = opts.httpOnly !== undefined ? opts.httpOnly : true;
    }
    set expires(to) {
        this._expires = to;
        if (this.maxAge)
            this.originalMaxAge = this.maxAge;
    }
    get expires() {
        return this._expires;
    }
    set maxAge(ms) {
        this.expires = ms ? new Date(Date.now() + ms) : false;
    }
    get maxAge() {
        return this.expires instanceof Date ? this.expires.valueOf() - Date.now() : null;
    }
    get data() {
        return {
            originalMaxAge: this.originalMaxAge,
            expires: this._expires instanceof Date ? this._expires : undefined,
            secure: this.secure,
            httpOnly: this.httpOnly,
            domain: this.domain,
            path: this.path,
            sameSite: this.sameSite
        };
    }
    serialize(name, val) {
        return cookie__namespace.serialize(name, val, this.data);
    }
}
class Session {
    constructor(req, sessionData) {
        Object.defineProperty(this, 'req', {
            value: req
        });
        this.id = '';
        Object.defineProperty(this, 'id', {
            value: req.sessionID
        });
        this.store = req.sessionStore;
        this.cookie = sessionData.cookie;
        if (typeof sessionData == 'object') {
            for (const prop in sessionData) {
                if (!(prop in this))
                    this[prop] = sessionData[prop];
            }
        }
    }
    resetMaxAge() {
        this.cookie.maxAge = this.cookie.originalMaxAge;
        return this;
    }
    touch() {
        this.resetMaxAge();
        return this;
    }
    data() {
        const out = {};
        for (const prop in this) {
            if (prop === 'cookie' || prop === 'store')
                continue;
            out[prop] = this[prop];
        }
        return out;
    }
    save(cb) {
        this.store.set(this.id, this.data(), cb ||
            function () {
                return;
            });
        return this;
    }
    reload(cb) {
        this.store.get(this.id, (err, sess) => {
            if (err)
                return cb && cb(err);
            if (!sess)
                return cb && cb(new Error('failed to load session'));
            this.store.createSession(this.req, sess);
            cb && cb(null);
        });
        return this;
    }
    destroy(cb) {
        this.store.destroy(this.id, cb);
        return this;
    }
    regenerate(cb) {
        this.store.regenerate(this.req, cb);
        return this;
    }
}
class Store extends events.EventEmitter {
    constructor() {
        super();
    }
    regenerate(req, cb) {
        const id = req.sessionID;
        this.destroy(id, (err) => {
            this.generate && this.generate(req);
            cb && cb(err);
        });
    }
    load(id, cb) {
        this.get(id, (err, session) => {
            if (err)
                return cb(err);
            if (!session)
                return cb(null);
            const req = {
                sessionID: id,
                sessionStore: this
            };
            cb(null, this.createSession(req, session));
        });
    }
    createSession(req, session) {
        const expires = session.cookie && session.cookie.expires;
        const originalMaxAge = session.cookie && session.cookie.originalMaxAge;
        session.cookie = new Cookie(session.cookie);
        if (typeof expires == 'string')
            session.cookie.expires = new Date(expires);
        session.cookie.originalMaxAge = originalMaxAge;
        req.session = new Session({
            sessionStore: this,
            sessionID: session.id
        }, session);
        return req.session;
    }
}
/**
 * Creates a `getSession` async function to get session data from `req` and `res` and save them to `store`.
 * Only `secret` option is required, all of the rest are optional.
 * Inherits all options from `SessionOptions`
 */
function SessionManager(options) {
    const opts = options || {};
    const generateId = opts.genid || generateSessionId;
    const name = opts.name || opts.key || 'micro.sid';
    const store = opts.store || new MemoryStore();
    let resaveSession = opts.resave;
    if (resaveSession === undefined)
        resaveSession = true;
    const rolling = opts.rolling;
    const cookieOptions = opts.cookie;
    let saveUninitialized = opts.saveUninitialized;
    if (saveUninitialized === undefined)
        saveUninitialized = true;
    if (opts.unset && opts.unset !== 'destroy' && opts.unset !== 'keep')
        throw new TypeError('unset option must be either destroy or keep');
    let secret;
    if (typeof opts.secret === 'string')
        secret = [opts.secret];
    else
        secret = opts.secret;
    if (!secret)
        throw new TypeError('session requires options.secret');
    if (process.env.NODE_ENV === 'production' && opts.store instanceof MemoryStore)
        console.warn('MemoryStore should not be used in production');
    let storeReady = true;
    store.on('disconnect', () => (storeReady = false));
    store.on('connect', () => (storeReady = false));
    store.generate = (req) => {
        req.sessionID = generateId(req);
        req.sessionStore = store;
        req.session = new Session(req, {});
        req.session.cookie = new Cookie(cookieOptions);
    };
    const storeImplementsTouch = typeof store.touch === 'function';
    return (req, res) => {
        return new Promise((resolve, reject) => {
            if (!storeReady) {
                resolve(undefined);
                return;
            }
            // pathname mismatch
            const originalPath = url__default['default'].parse(req.url).pathname || '/';
            if (cookieOptions && originalPath.indexOf(cookieOptions.path || '/') !== 0)
                return;
            let cookieId = getcookie(req, name, secret);
            let originalId;
            let originalHash;
            let savedHash;
            let session = undefined;
            let touched = false;
            const isModified = (session) => originalId !== session.id || originalHash !== hash(session);
            // check if session has been saved
            const isSaved = (sess) => originalId === sess.id && savedHash === hash(session);
            function shouldsetCookie(sessionID, session) {
                // cannot set cookie without a session ID
                if (typeof sessionID !== 'string' || !session)
                    return false;
                return cookieId !== sessionID
                    ? saveUninitialized || isModified(session)
                    : rolling || (session.cookie.expires != null && isModified(session));
            }
            // determine if session should be saved to store
            function shouldSave(id, session) {
                // cannot set cookie without a session ID
                if (typeof id !== 'string' || !session)
                    return false;
                return !saveUninitialized && cookieId !== id ? isModified(session) : !isSaved(session);
            }
            // determine if session should be touched
            const shouldTouch = (id, session) => typeof id !== 'string' ? false : cookieId === id && !shouldSave(id, session);
            // TODO: Get rid of onHeaders dep
            onHeaders__default['default'](res, () => {
                if (session === undefined)
                    return;
                if (!shouldsetCookie(cookieId, session))
                    return;
                if (!touched) {
                    session.touch();
                    touched = true;
                }
                setCookie(res, name, cookieId, secret[0], session.cookie.data);
            });
            const _end = res.end;
            const _write = res.write;
            let ended = false;
            res.end = (chunk, encoding) => {
                if (ended)
                    return false;
                ended = true;
                let ret;
                let sync = true;
                function writeEnd() {
                    if (sync) {
                        ret = _end.call(res, chunk, encoding);
                        sync = false;
                        return;
                    }
                    _end.call(res, null, '');
                }
                function writetop() {
                    if (!sync)
                        return ret;
                    if (chunk == null) {
                        ret = true;
                        return ret;
                    }
                    const contentLength = Number(res.getHeader('Content-Length'));
                    if (!isNaN(contentLength) && contentLength > 0) {
                        // measure chunk
                        chunk = !Buffer.isBuffer(chunk) ? Buffer.from(chunk, encoding) : chunk;
                        encoding = undefined;
                        if (chunk.length !== 0) {
                            ret = _write.call(res, chunk.slice(0, chunk.length - 1), encoding);
                            chunk = chunk.slice(chunk.length - 1, chunk.length);
                            return ret;
                        }
                    }
                    ret = _write.call(res, chunk, encoding);
                    sync = false;
                    return ret;
                }
                // no session to save
                if (!session)
                    return _end.call(res, chunk, encoding);
                if (!touched) {
                    // touch session
                    session.touch();
                    touched = true;
                }
                if (shouldSave(cookieId, session)) {
                    session.save((err) => {
                        if (err) {
                            setImmediate(reject, err);
                            return;
                        }
                        writeEnd();
                    });
                    return writetop();
                }
                else if (storeImplementsTouch && shouldTouch(cookieId, session)) {
                    // store implements touch method
                    store.touch(cookieId, session, (err) => {
                        if (err)
                            setImmediate(reject, err);
                        writeEnd();
                    });
                    return writetop();
                }
                return _end.call(res, chunk, encoding);
            };
            // generate the session
            function generate() {
                const fakeReq = req;
                fakeReq.sessionID = cookieId;
                fakeReq.session = session;
                store.generate && store.generate(fakeReq);
                originalId = fakeReq.sessionID;
                originalHash = hash(fakeReq.session);
                session = fakeReq.session;
                cookieId = fakeReq.sessionID;
                wrapmethods(session);
            }
            // inflate the session
            function inflate(req, sess) {
                store.createSession(req, sess);
                originalId = req.sessionID;
                originalHash = hash(sess);
                if (!resaveSession)
                    savedHash = originalHash;
                wrapmethods(req.session);
                session = req.session;
            }
            // wrap session methods
            function wrapmethods(sess) {
                const _reload = sess.reload;
                const _save = sess.save;
                function reload(callback, ...args) {
                    _reload.call(this, function () {
                        wrapmethods(session);
                        callback(args);
                    });
                }
                function save(cb) {
                    savedHash = hash(this);
                    _save.apply(this, [cb]);
                }
                Object.defineProperty(sess, 'reload', {
                    configurable: true,
                    enumerable: false,
                    value: reload,
                    writable: true
                });
                Object.defineProperty(sess, 'save', {
                    configurable: true,
                    enumerable: false,
                    value: save,
                    writable: true
                });
            }
            // generate a session if the browser doesn't send a sessionID
            if (!cookieId) {
                generate();
                resolve(session);
                return;
            }
            // generate the session object
            store.get(cookieId, (err, sess) => {
                // error handling
                if (err && err.code !== 'ENOENT') {
                    reject(err);
                    return;
                }
                try {
                    if (err || !sess)
                        generate();
                    else
                        inflate(req, sess);
                }
                catch (e) {
                    reject(e);
                    return;
                }
                resolve(session);
            });
        });
    };
}
function unsignCookie(val, secrets) {
    for (const secret of secrets) {
        const result = signature__namespace.unsign(val, secret);
        if (result !== false)
            return result;
    }
    return false;
}
function setCookie(res, name, val, secret, options) {
    const signed = 's:' + signature__namespace.sign(val, secret);
    const data = cookie__namespace.serialize(name, signed, options);
    const prev = res.getHeader('Set-Cookie') || [];
    const header = Array.isArray(prev) ? prev.concat(data) : [prev, data];
    res.setHeader('Set-Cookie', header);
}
function getcookie(req, name, secrets) {
    const header = req.headers.cookie;
    let raw;
    let val;
    // read from cookie header
    if (header) {
        const cookies = cookie__namespace.parse(header);
        raw = cookies[name];
        if (raw) {
            if (raw.substr(0, 2) === 's:') {
                val = unsignCookie(raw.slice(2), secrets);
                if (val === false)
                    val = undefined;
            }
        }
    }
    return val;
}
/**
 * Store in memory. Don't use it in production!
 */
class MemoryStore extends Store {
    constructor() {
        super();
        this.sessions = {};
    }
    all(cb) {
        const sessionIds = Object.keys(this.sessions);
        const sessions = {};
        for (const id of sessionIds) {
            const session = this.getSession(id);
            if (session)
                sessions[id] = session;
        }
        cb && setImmediate(() => cb(null, sessions));
    }
    /**
     * Clear all sessions
     * @param cb Callback
     */
    clear(cb) {
        this.sessions = {};
        cb && setImmediate(() => cb(null));
    }
    /**
     * Destroy the session associated with the given session ID.
     * @param id Session ID
     * @param cb Callback
     */
    destroy(id, cb) {
        delete this.sessions[id];
        cb && setImmediate(() => cb(null));
    }
    /**
     * Fetch session by the given session ID.
     * @param id Session ID
     * @param cb Callback
     */
    get(id, cb) {
        const session = this.getSession(id);
        setImmediate(() => cb(null, session));
    }
    /**
     * Commit the given session associated with the given ID to the store.
     * @param id Session ID
     * @param session Session object
     * @param cb Callback
     */
    set(id, session, cb) {
        this.sessions[id] = JSON.stringify(session);
        cb && setImmediate(() => cb(null));
    }
    /**
     * Get number of active sessions.
     * @param cb Callback
     */
    length(cb) {
        this.all((_, sessions) => {
            if (!sessions)
                return cb(null, 0);
            cb(null, Object.keys(sessions).length);
        });
    }
    /**
     * Touch the given session object associated with the given session ID.
     * @param id Session ID
     * @param session Session Object
     * @param cb Callback
     */
    touch(id, session, cb) {
        const currentSession = this.getSession(id);
        if (currentSession) {
            currentSession.cookie = session.cookie;
            this.sessions[session] = JSON.stringify(currentSession);
        }
        cb && setImmediate(() => cb(null));
    }
    /**
     * Get session from the store.
     * @param id  Session ID
     */
    getSession(id) {
        const sess = this.sessions[id];
        if (!sess)
            return;
        const sessJSON = JSON.parse(sess);
        if (sessJSON.cookie) {
            let expires;
            if (!(sessJSON.cookie.expires instanceof Date))
                expires = new Date(sessJSON.cookie.expires);
            else
                expires = sessJSON.cookie.expires;
            if (expires && expires <= new Date(Date.now())) {
                delete this.sessions[id];
                return;
            }
        }
        return sessJSON;
    }
}

exports.Cookie = Cookie;
exports.MemoryStore = MemoryStore;
exports.Session = Session;
exports.SessionManager = SessionManager;
exports.Store = Store;
