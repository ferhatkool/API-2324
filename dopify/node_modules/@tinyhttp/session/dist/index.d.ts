/// <reference types="node" />
import { Store as ExpressStore } from 'express-session';
import { IncomingMessage, ServerResponse } from 'http';
import { EventEmitter } from 'events';
interface ReqAndSessionInfo extends IncomingMessage {
    sessionID: string;
    session: Session;
    sessionStore: Store;
}
export declare class Cookie implements Express.SessionCookie {
    private _expires;
    originalMaxAge: number;
    secure: boolean;
    httpOnly: boolean;
    path: string;
    domain?: string;
    sameSite: boolean | 'lax' | 'strict' | 'none' | undefined;
    constructor(options?: Partial<Express.SessionCookieData>);
    set expires(to: Date | boolean);
    get expires(): Date | boolean;
    set maxAge(ms: number | null);
    get maxAge(): number | null;
    get data(): {
        originalMaxAge: number;
        expires: Date;
        secure: boolean;
        httpOnly: boolean;
        domain: string;
        path: string;
        sameSite: boolean | "lax" | "strict" | "none";
    };
    serialize(name: string, val: string): string;
}
export declare class Session implements Express.Session {
    id: string;
    req: any;
    store: Store;
    cookie: Cookie;
    [key: string]: any;
    constructor(req: any, sessionData: any);
    resetMaxAge(): this;
    touch(): this;
    private data;
    save(cb?: (err?: any) => void): this;
    reload(cb?: (err?: any) => void): this;
    destroy(cb?: (err?: any) => void): this;
    regenerate(cb: (err?: any) => void): this;
}
export declare abstract class Store extends EventEmitter {
    constructor();
    abstract destroy(id: string, cb?: (err?: any) => void): void;
    abstract get(id: string, cb: (err?: any, session?: any) => void): void;
    abstract set(id: string, session: any, cb?: (err?: any) => void): void;
    abstract touch(id: string, session: any, cb?: (err?: any) => void): void;
    generate?: (req: ReqAndSessionInfo) => void;
    regenerate(req: any, cb?: (err?: any) => void): void;
    load(id: string, cb: (err: any, session?: Express.SessionData | null) => any): void;
    createSession(req: any, session: any): any;
}
export declare type SessionOptions = Partial<{
    /**
     * Function to call to generate a new session ID. Provide a function that returns a string that will be used as a session ID.
     * he function is given `req` as the first argument if you want to use some value attached to `req` when generating the ID.
     */
    genid: (req: ReqAndSessionInfo) => string;
    /**
     * The name of the session ID cookie to set in the response (and read from in the request).
     * The default value is `'connect.sid'`.
     */
    name: string;
    key: string;
    store: Store;
    /**
     * Forces the session to be saved back to the session store, even if the session was never modified during the request.
     * Depending on your store this may be necessary, but it can also create race conditions where a client makes two parallel requests to your server and changes made to the session in one request may get overwritten when the other request ends, even if it made no changes (this behavior also depends on what store you're using).
     */
    resave: boolean;
    /**
     * Force the session identifier cookie to be set on every response. The expiration is reset to the original maxAge, resetting the expiration countdown.
     * The default value is `false`.
     */
    rolling: boolean;
    /**
     * Forces a session that is "uninitialized" to be saved to the store.
     * A session is uninitialized when it is new but not modified.
     * Choosing `false` is useful for implementing login sessions, reducing server storage usage, or complying with laws that require permission before setting a cookie.
     */
    saveUninitialized: boolean;
    /**
     * Control the result of unsetting `req.session` (through `delete`, setting to `null`, etc.).
     * The default value is `'keep'`.
     */
    unset: string;
    /**
     * Settings object for the session ID cookie.
     */
    cookie: Partial<Express.SessionCookieData>;
}> & {
    secret: string | string[];
};
/**
 * Creates a `getSession` async function to get session data from `req` and `res` and save them to `store`.
 * Only `secret` option is required, all of the rest are optional.
 * Inherits all options from `SessionOptions`
 */
export declare function SessionManager(options?: SessionOptions): (req: IncomingMessage, res: ServerResponse) => Promise<Session>;
/**
 * Store in memory. Don't use it in production!
 */
export declare class MemoryStore extends Store implements ExpressStore {
    private sessions;
    constructor();
    all(cb: (err?: any, sessions?: Record<string, any>) => void): void;
    /**
     * Clear all sessions
     * @param cb Callback
     */
    clear(cb?: (err?: any) => void): void;
    /**
     * Destroy the session associated with the given session ID.
     * @param id Session ID
     * @param cb Callback
     */
    destroy(id: string, cb?: (err?: any) => void): void;
    /**
     * Fetch session by the given session ID.
     * @param id Session ID
     * @param cb Callback
     */
    get(id: string, cb: (err?: any, session?: any) => void): void;
    /**
     * Commit the given session associated with the given ID to the store.
     * @param id Session ID
     * @param session Session object
     * @param cb Callback
     */
    set(id: string, session: unknown, cb?: (err?: any) => void): void;
    /**
     * Get number of active sessions.
     * @param cb Callback
     */
    length(cb: (err?: any, length?: number) => void): void;
    /**
     * Touch the given session object associated with the given session ID.
     * @param id Session ID
     * @param session Session Object
     * @param cb Callback
     */
    touch(id: string, session: any, cb?: (err?: any) => void): void;
    /**
     * Get session from the store.
     * @param id  Session ID
     */
    private getSession;
}
export {};
